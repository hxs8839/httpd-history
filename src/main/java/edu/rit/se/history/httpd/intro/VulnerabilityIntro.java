package edu.rit.se.history.httpd.intro;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 
 */

/**
 * @author harsha
 * 
 */
public class VulnerabilityIntro {

	/**
	 * Call the getPatch method to find the commit hash in git that fixed the given vulnerability. this will
	 * be input to git bisect as a good version
	 * @param args
	 */
	public static void main(String[] args) {
		String commitHash = null;
		try {
			commitHash = getPatch(args[0], args[1]);
			System.out.println("Commit that Fixed the vulnerability is::" + commitHash);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Each commit to git has a unique commit message. This is the basis on which we search for. Searching
	 * for the patch involves parsing the entire file, which might affect performance. Hence the use of the
	 * commit message, which is unique to each commit
	 * @param fileName
	 * @return commitHash the commit that fixed the vulnerability for the given cve
	 * @throws InterruptedException
	 * @throws IOException
	 */
	public static String getPatch(String fileName, String message) throws InterruptedException, IOException {
		Process process = null;
		String tempStr = null;
		String commitHash = null;
		try {
			Runtime runtime = Runtime.getRuntime();
			process = runtime.exec("git log --follow --pretty=format:\"%H/%s\" ".concat(fileName));

			BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
			while ((tempStr = stdInput.readLine()) != null) {
				// System.out.println(tempStr.concat("\n"));
				if (tempStr.contains(message)) {
					System.out.println(tempStr);
					String[] commit = tempStr.split("/");
					commitHash = commit[0];
				}
			}
			stdInput.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return commitHash;
	}

}
